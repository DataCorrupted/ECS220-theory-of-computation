\input{hw4.tex}
\begin{document}
\maketitle
\thispagestyle{firststyle}
\vspace{-2.0cm}
\section{More undecidable problems. }
\begin{quote}
    Show that it is undecidable, given the source code of a program $Q$, to tell whether or not any of the following is true:
    \begin{enumerate}[(i)]
      \item $Q$ halts on input 0.
      \item $Q$ is total -- that is, $Q(y)$ halts for all $y$.
      \item $Q(y)=$ {\tt true} for all $y$.
      \item The set of $y$ on which $Q$ halts is finite.
      \item There is a $y$ such that $Q(y)= y$.
      \item Given a second program $R$, $Q$ is equivalent to $R$.
      That is, even though $Q$ and $R$ have different source codes,
      they compute the same partial function --
      for all $y$, either $Q(y)$ and $R(y)$ both halt and return the same answer, or neither halts.
    \end{enumerate}
    Prove each of these by reducing $\textsc{Halting}$ to them.
    That is, show to how convert an instance $(P, x)$ of $\textsc{Halting}$ to an instance of the problem above.
    For instance, you can modify $P$'s source code,
    or write a new program that calls $P$ as a subroutine.
    Each of these is asking for a Turing reduction;
    your reduction does not necessarily have to map yes-instances to yes-instances and no-instances to no-instances --
    all that matters is that if you could solve the problem,
    then you could solve $\textsc{Halting}$.
\end{quote}

\section*{Solution}

\begin{enumerate}[(i)]
    \item We show that HALTING$\leq$ (i)\\
    For the given arbitrary instance $(P, x)$, we build $Q_{P,x}$ like below:
    \begin{lstlisting}[language=python]
    def Q_Px(y):
        if y==0:
           P(x)
        else:
           return
    \end{lstlisting}
    We can see that for any input 0, the program $Q$ will run the problem $P(x)$, the instance of the Halting problem.\\
    So we can get that: $P(x)$ halts $\Leftrightarrow$ $Q_{P,x}(y)$ halts.
    \item We show that HALTING$\leq$ (ii)\\
    For the given arbitrary instance $(P, x)$, we build $Q_{P,x}$ like below:
    \begin{lstlisting}[language=python]
    def Q_Px(y):
        P(x)
        
    \end{lstlisting}
    We can see that for any input $y$, the program $Q$ will run the problem $P(x)$, the instance of the Halting problem.\\
    So we can get that: $P(x)$ halts $\Leftrightarrow$ $Q_{P,x}(y)$ halts.
    \item We show that HALTING$\leq$ (iii)\\
    For the given arbitrary instance $(P, x)$, we build $Q_{P,x}$ like below:
    \begin{lstlisting}[language=python]
    def Q_Px(y):
        if HALTS(P,x):
           return True
        return False
    \end{lstlisting}
    We can see that $Q(y)=$ {\tt true} for all $y$ if and only if happens when the instance $P(x)$ halts.\\
    So we can get that: $P(x)$ halts $\Leftrightarrow$ $Q_{P,x}(y)$.
\end{enumerate}

\end{document}